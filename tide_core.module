<?php

/**
 * @file
 * Contains tide_core.module.
 */

use Drupal\Core\Entity\ContentEntityType;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Url;
use Drupal\scheduled_transitions\Routing\ScheduledTransitionsRouteProvider;
use Drupal\tide_core\Form\TideCoreScheduledPublishingForm;
use Drupal\tide_core\Form\Entity\TideCoreScheduledPublishingAddForm;
use Drupal\views\ViewExecutable;
use Drupal\workflows\Entity\Workflow;

/**
 * Implements hook_views_data_alter().
 *
 * @see \Drupal\node\NodeViewsData::getViewsData()
 * @see \Drupal\tide_core\Plugin\views\filter\StatusModerated
 */
function tide_core_views_data_alter(array &$data) {
  // Add Moderation support to Node 'status_extra' filter.
  // Content Overview view uses the filter 'Published status or admin user'
  // without any consideration of Content Moderation. We override this filter
  // to add an extra check for the 'view any unpublished content' permission
  // provided by the Content Moderation module.
  $data['node_field_data']['status_extra']['filter']['id'] = 'node_status_moderated';
}

/**
 * Implements hook_views_query_substitutions().
 *
 * @see node_views_query_substitutions()
 * @see \Drupal\node\Plugin\views\filter\Status::query()
 * @see \Drupal\tide_core\Plugin\views\filter\StatusModerated::query()
 */
function tide_core_views_query_substitutions(ViewExecutable $view) {
  $account = \Drupal::currentUser();
  return [
    '***VIEW_ANY_UNPUBLISHED_NODES***' => intval($account->hasPermission('view any unpublished content')),
  ];
}

/**
 * Implements hook_entity_operation().
 */
function tide_core_entity_operation(EntityInterface $entity) {
  // Add "Archived" operation link to entities.
  $operations = [];
  $workflow = Workflow::load('editorial');
  if ($workflow) {
    if ($workflow->getTypePlugin()
      ->appliesToEntityTypeAndBundle($entity->getEntityTypeId(), $entity->bundle())) {
      if ($entity->access('use ' . $workflow->id() . ' transition archived')) {
        $operations['archive'] = [
          'title' => t('Archive'),
          'weight' => 100,
          'url' => Url::fromRoute('tide_core.entity.archive_confirm', ['bundle' => $entity->getEntityTypeId(), 'entity_type_id' => $entity->id()]),
        ];
      }
    }
  }

  return $operations;
}

/**
 * Implements hook_local_tasks_alter().
 */
function tide_core_local_tasks_alter(&$local_tasks) {
  if (isset($local_tasks['scheduled_transitions.tasks:node.scheduled_transitions'])) {
    $local_tasks['scheduled_transitions.tasks:node.scheduled_transitions']['title'] = \t('Scheduled publishing');
  }
}

/**
 * Implements hook_menu_local_actions_alter().
 */
function tide_core_menu_local_actions_alter(&$local_actions) {
  if (isset($local_actions['scheduled_transitions.actions:node.add_scheduled_transition'])) {
    $local_actions['scheduled_transitions.actions:node.add_scheduled_transition']['title'] = \t('Add Scheduled publishing');
  }
}

/**
 * Implements hook_entity_type_build().
 */
function tide_core_entity_type_build(array &$entity_types) {
  if (\Drupal::moduleHandler()->moduleExists('scheduled_transitions')) {
    foreach ($entity_types as $entityType) {
      if (!$entityType->hasLinkTemplate('canonical') || !$entityType instanceof ContentEntityType) {
        continue;
      }
      if ($entityType->id() === 'scheduled_transition') {
        continue;
      }
      $entityType->setFormClass(ScheduledTransitionsRouteProvider::FORM_ADD, TideCoreScheduledPublishingAddForm::class);
      $entityType->setFormClass(ScheduledTransitionsRouteProvider::FORM, TideCoreScheduledPublishingForm::class);
    }
  }
}
