<?php

/**
 * @file
 * Contains tide_core.module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Url;
use Drupal\views\ViewExecutable;
use Drupal\workflows\Entity\Workflow;

/**
 * Implements hook_views_data_alter().
 *
 * @see \Drupal\node\NodeViewsData::getViewsData()
 * @see \Drupal\tide_core\Plugin\views\filter\StatusModerated
 */
function tide_core_views_data_alter(array &$data) {
  // Add Moderation support to Node 'status_extra' filter.
  // Content Overview view uses the filter 'Published status or admin user'
  // without any consideration of Content Moderation. We override this filter
  // to add an extra check for the 'view any unpublished content' permission
  // provided by the Content Moderation module.
  $data['node_field_data']['status_extra']['filter']['id'] = 'node_status_moderated';
}

/**
 * Implements hook_views_query_substitutions().
 *
 * @see node_views_query_substitutions()
 * @see \Drupal\node\Plugin\views\filter\Status::query()
 * @see \Drupal\tide_core\Plugin\views\filter\StatusModerated::query()
 */
function tide_core_views_query_substitutions(ViewExecutable $view) {
  $account = \Drupal::currentUser();
  return [
    '***VIEW_ANY_UNPUBLISHED_NODES***' => intval($account->hasPermission('view any unpublished content')),
  ];
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function tide_core_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $user = \Drupal::currentUser();
  // Hide Schedule Publishing & Archiving containers from editors,
  // because scheduled_updates module does not set it properly.
  if (isset($form['scheduled_publishing'])) {
    if (!$user->hasPermission('administer scheduled updates') &&
      !$user->hasPermission('create scheduled_publishing scheduled updates') &&
      !$user->hasPermission('edit scheduled_publishing scheduled updates')
    ) {
      $form['scheduled_publishing']['#access'] = FALSE;
    }
  }

  if (isset($form['scheduled_archiving'])) {
    if (!$user->hasPermission('administer scheduled updates') &&
      !$user->hasPermission('create scheduled_archiving scheduled updates') &&
      !$user->hasPermission('edit scheduled_archiving scheduled updates')
    ) {
      $form['scheduled_archiving']['#access'] = FALSE;
    }
  }

  // Then move Scheduled Updates controls to the footer region.
  if (isset($form['footer'])) {
    if (isset($form['scheduled_publishing'])) {
      $form['footer']['scheduled_publishing'] = $form['scheduled_publishing'];
      unset($form['scheduled_publishing']);
    }

    if (isset($form['scheduled_archiving'])) {
      $form['footer']['scheduled_archiving'] = $form['scheduled_archiving'];
      unset($form['scheduled_archiving']);
    }
  }
}

/**
 * Implements hook_entity_operation().
 */
function tide_core_entity_operation(EntityInterface $entity) {
  // Add "Archived" operation link to entities.
  $operations = [];
  $workflow = Workflow::load('editorial');
  if ($workflow) {
    if ($workflow->getTypePlugin()
      ->appliesToEntityTypeAndBundle($entity->getEntityTypeId(), $entity->bundle())) {
      if ($entity->access('use ' . $workflow->id() . ' transition archived')) {
        $operations['archive'] = [
          'title' => t('Archive'),
          'weight' => 100,
          'url' => Url::fromRoute('tide_core.entity.archive_confirm', ['bundle' => $entity->getEntityTypeId(), 'entity_type_id' => $entity->id()]),
        ];
      }
    }
  }

  return $operations;
}
